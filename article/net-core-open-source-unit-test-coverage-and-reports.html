<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><title>.NET Core - Open Source Unit Test Coverage and Reports</title><base target="_blank"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/708f2af5a4cdf0fda191.css" as="style"/><link rel="stylesheet" href="/_next/static/css/708f2af5a4cdf0fda191.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.4b81eedf2fcdb09bf521.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.4825e5e9d187cd4ab7dd.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-86c34d104cdfe5877fdd.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-3972a0229e6401e497b7.js" as="script"/><link rel="preload" href="/_next/static/chunks/63c1bd8fe8e29f7d1674476eb835b66f2691ac72.43955d3384b90be5bcd0.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/article/%5Bid%5D-898c033ca875c80508bb.js" as="script"/></head><body><div id="__next"><div class="container sm:m-auto"><header><div class="flex space-x-5 justify-end mt-5 mr-2 lg:mr-0"><a class="w-16 h-16" href="/"><img class="m-0 rounded-full border border-gray-100 shadow-sm" src="/images/profile.png" alt="Federico Antuña"/></a><div class="self-center"><h2 class="m-0 text-2xl font-normal"><a href="/">Federico Antuña</a></h2><h2 class="m-0 text-sm font-normal">Software Developer</h2><div class="flex justify-center space-x-1 mt-1"><div><a href="https://www.linkedin.com/in/federicoantuna/" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="w-4 h-4 fill-current text-gray-400 hover:text-blue-500"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a></div><div><a href="https://github.com/fedeantuna" target="_blank"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="w-4 h-4 fill-current text-gray-400 hover:text-black"><path d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM277.3 415.7c-8.4 1.5-11.5-3.7-11.5-8 0-5.4.2-33 .2-55.3 0-15.6-5.2-25.5-11.3-30.7 37-4.1 76-9.2 76-73.1 0-18.2-6.5-27.3-17.1-39 1.7-4.3 7.4-22-1.7-45-13.9-4.3-45.7 17.9-45.7 17.9-13.2-3.7-27.5-5.6-41.6-5.6-14.1 0-28.4 1.9-41.6 5.6 0 0-31.8-22.2-45.7-17.9-9.1 22.9-3.5 40.6-1.7 45-10.6 11.7-15.6 20.8-15.6 39 0 63.6 37.3 69 74.3 73.1-4.8 4.3-9.1 11.7-10.6 22.3-9.5 4.3-33.8 11.7-48.3-13.9-9.1-15.8-25.5-17.1-25.5-17.1-16.2-.2-1.1 10.2-1.1 10.2 10.8 5 18.4 24.2 18.4 24.2 9.7 29.7 56.1 19.7 56.1 19.7 0 13.9.2 36.5.2 40.6 0 4.3-3 9.5-11.5 8-66-22.1-112.2-84.9-112.2-158.3 0-91.8 70.2-161.5 162-161.5S388 165.6 388 257.4c.1 73.4-44.7 136.3-110.7 158.3zm-98.1-61.1c-1.9.4-3.7-.4-3.9-1.7-.2-1.5 1.1-2.8 3-3.2 1.9-.2 3.7.6 3.9 1.9.3 1.3-1 2.6-3 3zm-9.5-.9c0 1.3-1.5 2.4-3.5 2.4-2.2.2-3.7-.9-3.7-2.4 0-1.3 1.5-2.4 3.5-2.4 1.9-.2 3.7.9 3.7 2.4zm-13.7-1.1c-.4 1.3-2.4 1.9-4.1 1.3-1.9-.4-3.2-1.9-2.8-3.2.4-1.3 2.4-1.9 4.1-1.5 2 .6 3.3 2.1 2.8 3.4zm-12.3-5.4c-.9 1.1-2.8.9-4.3-.6-1.5-1.3-1.9-3.2-.9-4.1.9-1.1 2.8-.9 4.3.6 1.3 1.3 1.8 3.3.9 4.1zm-9.1-9.1c-.9.6-2.6 0-3.7-1.5s-1.1-3.2 0-3.9c1.1-.9 2.8-.2 3.7 1.3 1.1 1.5 1.1 3.3 0 4.1zm-6.5-9.7c-.9.9-2.4.4-3.5-.6-1.1-1.3-1.3-2.8-.4-3.5.9-.9 2.4-.4 3.5.6 1.1 1.3 1.3 2.8.4 3.5zm-6.7-7.4c-.4.9-1.7 1.1-2.8.4-1.3-.6-1.9-1.7-1.5-2.6.4-.6 1.5-.9 2.8-.4 1.3.7 1.9 1.8 1.5 2.6z"></path></svg></a></div></div></div></div></header><main class="mr-3 ml-3 lg:mr-0 lg:ml-0"><article><h1>.NET Core - Open Source Unit Test Coverage and Reports</h1><div class="text-center text-sm"><time dateTime="2020-10-11">October 11, 2020</time></div><div class="mt-2 mb-5"><p>When I work on my personal projects I normally use Visual Studio Community or Visual Studio Code. Lately I decided to pay more attention to the coverage on those projects, and being used to having the Visual Studio Enterprise subscription on my job, I tried to run the "Analyze Code Coverage for All Tests" from Visual Studio. It turns out that that options is only available for the Enterprise edition. After a second of frustration it came to my mind the question "if I depend on Visual Studio to analyze the code coverage, what am I going to do when working on my Fedora laptop?", so I did some investigation and found a way (there a lot of ways actually) to run the analysis on both, my Windows and Linux machines.</p>
<h2>Code on GitHub</h2>
<p><a href="https://github.com/fedeantuna/UnitTestCoverageDemo">GitHub link</a></p>
<h2>Setting up the demo projects</h2>
<p>In order to provide a more "realistic" scenario, I will be creating multiple projects. I will also use mostly the console so it doesn't matter what OS or editor you are using, you should be able to follow along. Keep in mind that in some cases you'll to change the forward slashes to backslashes on Windows.</p>
<p>Open the console and navigate to any directory where you want to set up the solution and run:</p>
<pre><code>mkdir UnitTestCoverageDemo
cd UnitTestCoverageDemo
dotnet new sln
mkdir src
mkdir tests
cd src
dotnet new classlib -n UnitTestCoverageDemo.Calculations
dotnet new classlib -n UnitTestCoverageDemo.Services
dotnet add UnitTestCoverageDemo.Services/UnitTestCoverageDemo.Services.csproj reference UnitTestCoverageDemo.Calculations/UnitTestCoverageDemo.Calculations.csproj
cd ../tests
dotnet new xunit -n UnitTestCoverageDemo.Calculations.Tests
dotnet new xunit -n UnitTestCoverageDemo.Services.Tests
dotnet add UnitTestCoverageDemo.Calculations.Tests/UnitTestCoverageDemo.Calculations.Tests.csproj reference ../src/UnitTestCoverageDemo.Calculations/UnitTestCoverageDemo.Calculations.csproj
dotnet add UnitTestCoverageDemo.Services.Tests/UnitTestCoverageDemo.Services.Tests.csproj reference ../src/UnitTestCoverageDemo.Services/UnitTestCoverageDemo.Services.csproj
cd ..
dotnet sln UnitTestCoverageDemo.sln add ./**/**/**.csproj
</code></pre>
<p>Now lets open the solution using some editor. First, delete every auto-generated class and then create a couple of classes for each non-test project.</p>
<p>On UnitTestCoverageDemo.Calculations, create SimpleCalculation.cs.</p>
<pre><code>using System;

namespace UnitTestCoverageDemo.Calculations
{
    public class SimpleCalculation
    {
        public Int32 Add(Int32 n, Int32 m)
        {
            return n + m;
        }

        public Int32 Substract(Int32 n, Int32 m)
        {
            return n - m;
        }

        public Int32 Multiply(Int32 n, Int32 m)
        {
            return n * m;
        }

        public Int32 Divide(Int32 n, Int32 m)
        {
            if (m == 0)
            {
                throw new ArgumentOutOfRangeException(nameof(m));
            }

            return n / m;
        }
    }
}
</code></pre>
<p>On UnitTestCoverageDemo.Calculations, create ComplexCalculation.cs.</p>
<pre><code>using System;

namespace UnitTestCoverageDemo.Calculations
{
    public class ComplexCalculation
    {
        public Int32 Power(Int32 n, Int32 m)
        {
            if (m == 0)
            {
                return 1;
            }

            var result = n;
            for (int i = 1; i &#x3C; m; i++)
            {
                result *= n;
            }

            return result;
        }

        public Int32 Round(Decimal n)
        {
            var intPart = (Int32)n;
            var difference = n - intPart;

            if (difference >= 0.5M)
            {
                return intPart + 1;
            }

            return intPart;
        }
    }
}
</code></pre>
<p>On UnitTestCoverageDemo.Services, create FigureService.cs.</p>
<pre><code>using System;
using UnitTestCoverageDemo.Calculations;

namespace UnitTestCoverageDemo.Services
{
    public class FigureService
    {
        private readonly SimpleCalculation _simpleCalculation;
        private readonly ComplexCalculation _complexCalculation;

        public FigureService()
        {
            // Who's got time for DI anyways?
            this._simpleCalculation = new SimpleCalculation();
            this._complexCalculation = new ComplexCalculation();
        }

        public Int32 SquareArea(Int32 s)
        {
            var area = this._complexCalculation.Power(s, 2);

            return area;
        }

        public Int32 RectangleArea(Int32 b, Int32 h)
        {
            var area = this._simpleCalculation.Multiply(b, h);

            return area;
        }

        public Int32 TriangleArea(Int32 b, Int32 h)
        {
            var doubleArea = this._simpleCalculation.Multiply(b, h);
            var area = this._simpleCalculation.Divide(doubleArea, 2);

            return area;
        }

        public Int32 RectanglePerimeter(Int32 b, Int32 h)
        {
            var halfPerimeter = this._simpleCalculation.Add(b, h);
            var perimeter = this._simpleCalculation.Multiply(halfPerimeter, 2);

            return perimeter;
        }
    }
}
</code></pre>
<p>On UnitTestCoverageDemo.Services, create MoneyService.cs.</p>
<pre><code>using System;
using UnitTestCoverageDemo.Calculations;

namespace UnitTestCoverageDemo.Services
{
    public class MoneyService
    {
        private readonly SimpleCalculation _simpleCalculation;
        private readonly ComplexCalculation _complexCalculation;

        public MoneyService()
        {
            // Who's got time for DI anyways?
            this._simpleCalculation = new SimpleCalculation();
            this._complexCalculation = new ComplexCalculation();
        }

        public Int32 Spend(Int32 money, Int32 price)
        {
            if (money &#x3C; price)
            {
                throw new ArgumentOutOfRangeException(nameof(price));
            }

            var left = this._simpleCalculation.Substract(money, price);

            return left;
        }

        public Int32 ForgetTheChange(Decimal money)
        {
            var withoutTheChange = this._complexCalculation.Round(money);

            return withoutTheChange;
        }
    }
}
</code></pre>
<p>On UnitTestCoverageDemo.Calculations.Tests, create ComplexCalculationTests.cs.</p>
<pre><code>using System;
using Xunit;

namespace UnitTestCoverageDemo.Calculations.Tests
{
    public class ComplexCalculationTests
    {
        private readonly ComplexCalculation _sut;

        public ComplexCalculationTests()
        {
            this._sut = new ComplexCalculation();
        }

        [Theory]
        [InlineData(5, 2, 25)]
        [InlineData(2, 3, 8)]
        [InlineData(5, 0, 1)]
        public void Power_Returns_FirstParameterElevatedToTheSecondParameter(Int32 firstParameter, Int32 secondParameter, Int32 expectedResult)
        {
            // Arrange

            // Act
            var result = this._sut.Power(firstParameter, secondParameter);

            // Assert
            Assert.Equal(expectedResult, result);
        }

        [Theory]
        [InlineData(5.25, 5)]
        [InlineData(7.5, 8)]
        [InlineData(6.75, 7)]
        public void Round_Returns_RoundedNumber(Decimal number, Int32 expectedResult)
        {
            // Arrange

            // Act
            var result = this._sut.Round(number);

            // Assert
            Assert.Equal(expectedResult, result);
        }
    }
}
</code></pre>
<p>On UnitTestCoverageDemo.Services.Tests, create MoneyServiceTests.cs.</p>
<pre><code>using System;
using Xunit;

namespace UnitTestCoverageDemo.Services.Tests
{
    public class MoneyServiceTests
    {
        private readonly MoneyService _sut;

        public MoneyServiceTests()
        {
            this._sut = new MoneyService();
        }

        [Theory]
        [InlineData(200, 50, 150)]
        [InlineData(300, 300, 0)]
        public void Spend_Returns_RemainingMoney(Int32 money, Int32 price, Int32 remaining)
        {
            // Arrange

            // Act
            var result = this._sut.Spend(money, price);

            // Assert
            Assert.Equal(remaining, result);
        }

        [Theory]
        [InlineData(10.89, 11)]
        [InlineData(250.35, 250)]
        public void ForgetTheChange_Returns_RoundedMoney(Decimal money, Int32 rounded)
        {
            // Arrange

            // Act
            var result = this._sut.ForgetTheChange(money);

            // Assert
            Assert.Equal(rounded, result);
        }
    }
}
</code></pre>
<h2>Installing required packages and tools</h2>
<p>Now that we have our project set, we can run our tests. Open a console on the solution directory and run:</p>
<pre><code>dotnet test
</code></pre>
<p>You'll see that they run successfully but no information about our current coverage, which of course is extremely poor. So, let's install what we need.</p>
<p>We need coverlet.collector NuGet package on each Unit Test project, we can check that they are installed running from the solution directory:</p>
<pre><code>dotnet list package
</code></pre>
<p>If the package appears on the list then we are ready to go, if not (or if you want to update it) run from each project directory:</p>
<pre><code>dotnet add package coverlet.collector
</code></pre>
<p>Now lets install the Report Generator as a global tool.</p>
<pre><code>dotnet tool install --global dotnet-reportgenerator-globaltool
</code></pre>
<p>If already installed, run:</p>
<pre><code>dotnet tool update --global dotnet-reportgenerator-globaltool
</code></pre>
<h2>Generating the report</h2>
<p>To generate the reports, we need to run the test command with some additional parameters that will generate files containing information about our coverage. We will use the cobertura format here but you can read about other formats <a href="https://github.com/coverlet-coverage/coverlet">here</a>.</p>
<p>Run the following command from the solution directory:</p>
<pre><code>dotnet test --collect:"XPlat Code Coverage" --results-directory:"./.coverage"
</code></pre>
<p>The "XPlat Code Coverage" argument is a friendly name that corresponds to the data collectors from Coverlet. You can read more about it <a href="https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-code-coverage">here</a>. The "./.coverage" is to specify the directory where the results will be stored. If none is specified, it will default to a TestResults directory inside each project.</p>
<p>Inside the ".coverage" directory we have now two directories with GUID as names and inside those directories we have two files named "coverage.cobertura.xml". Those files contain the result for our code coverage analysis, but unless you're fluent in XML (I'm not), then there is not much use for us as humans. So let's create a readable report that is friendlier to our eyes.</p>
<p>Run the following on the terminal from the solution directory:</p>
<pre><code>reportgenerator "-reports:.coverage/**/*.cobertura.xml" "-targetdir:.coverage-report/" "-reporttypes:HTML;"
</code></pre>
<p>If we now open the index.html file inside the .coverage-report directory, we will see a much nicer report that tells us that we suck at covering because we didn't even cover half of our code, but at least we now have all the details to easily correct this.</p>
<p>Before continuing let's analyze the command. Our first parameter "-reports:.coverage/*<em>/</em>.cobertura.xml" is going to find all the "coverage.cobertura.xml" files regardless of the GUID naming the directories. The second parameter "-targetdir:.coverage-report/" will just tell the Report Generator where to store the final report, and the last parameter "-reporttypes:HTML;" will generate an HTML report for us to view on the browser. If you want to know more in detail about all the possible options, you can read more here.</p>
<h2>Automating the process</h2>
<p>All of this is great, but it is really painful to run this manually every time, and besides that if you think of the directory structure that is going to be created for a second, you'll see a bigger problem... yeah, that's right, unless we delete everything before the next run we will have no way to identify which files are the ones for that run, because the GUIDs are randomly generated. Let's make everything better then with some scripts. I made a couple, one for Linux and one for Windows. If you are on a MAC I assume that the Linux one will work just fine, but it might need a few modifications.</p>
<p>Linux Script (BASH):</p>
<pre><code>#!/usr/bin/bash
# Parameters - Solution
SOLUTION_FILE_NAME=""
COVERAGE_COVERLET_DIR=".coverage"
COVERAGE_REPORT_DIR=".coverage-report"

# Parameters - Coverlet
DATA_COLLECTOR_FORMAT="cobertura"
COVERLET_OUTPUT_FORMAT="cobertura"
COVERLET_OUTPUT_EXTENSION=".xml"
COLLECT="XPlat Code Coverage"
COVERAGE_FILE_NAME="coverage.$COVERLET_OUTPUT_FORMAT$COVERLET_OUTPUT_EXTENSION"

# Parameters - Report Generator
REPORT_TYPES="HTML;cobertura;"
HTML_REPORT_INDEX_FILE_NAME="index.html"

# Calculated Parameters - Solution - CHANGE WITH EXTREME CAUTION
SOLUTION_DIR="$(dirname $(cd "$( dirname "${BASH_SOURCE[0]}" )" &#x26;&#x26; pwd))"
SOLUTION="$SOLUTION_DIR/$SOLUTION_FILE_NAME"

# Calculated Parameters - Coverlet - CHANGE WITH EXTREME CAUTION
COVERAGE_RUN_IDENTIFIER=$(uuidgen)
COVERLET_OUTPUT="$SOLUTION_DIR/$COVERAGE_COVERLET_DIR/$COVERAGE_RUN_IDENTIFIER"

# Build and Test
dotnet test $SOLUTION --collect:"$COLLECT" --results-directory:"$COVERLET_OUTPUT" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format="$DATA_COLLECTOR_FORMAT"

# Calculated Parameters - Report Generator - CHANGE WITH EXTREME CAUTION
TARGET_DIR="$COVERAGE_REPORT_DIR/$COVERAGE_RUN_IDENTIFIER"
REPORT_HTML_FILE="$SOLUTION_DIR/$COVERAGE_REPORT_DIR/$COVERAGE_RUN_IDENTIFIER/$HTML_REPORT_INDEX_FILE_NAME"
COVERAGE_FILES=$(find $COVERLET_OUTPUT/**/* -maxdepth 1 | awk -vORS=";" '{ print $1 }' | sed "s/\;$/\n/")

# Generate Report
reportgenerator "-reports:$COVERAGE_FILES" "-targetdir:$TARGET_DIR" "-reporttypes:$REPORT_TYPES"

# Open Report
xdg-open $REPORT_HTML_FILE > /dev/null 2>&#x26;1
</code></pre>
<p>For this script to run properly you will also need to install uuidgen tool. On Fedora, CentOS and RHEL (if not already installed) it is on the util-linux package, util-linux-ng for CentOS 6. On Debian the package is called uuid-runtime. On other distributions it might be better for you to search for it online or try running the uuidgen command to see if you already have it. Remember to also grant execution permissions to the script.</p>
<pre><code>chmod u+x run_tests.sh #or whatever name you used
</code></pre>
<p>Windows Script (Powershell):</p>
<pre><code># Parameters - Solution
$SolutionFileName = "WAM.sln"
$CoverageCoverletDir = ".coverage"
$CoverageReportDir = ".coverage-report"

# Parameters - Coverlet
$DataCollectorFormat = "cobertura"
$CoverletOutputFormat = "cobertura"
$CoverletOutputExtension = ".xml"
$Collect = "XPlat Code Coverage"
$CoverageFileName = "coverage.$CoverletOutputFormat$CoverletOutputExtension"

# Parameters - Report Generator
$ReportTypes = "HTML;cobertura;"
$HtmlReportIndexFileName = "index.html"

# Calculated Parameters - Solution - CHANGE WITH EXTREME CAUTION
$SolutionDir = (Get-Item $PSScriptRoot).Parent.FullName
$Solution = [IO.Path]::Combine($SolutionDir, $SolutionFileName)

# Calculated Parameters - Coverlet - CHANGE WITH EXTREME CAUTION
$CoverageRunIdentifier = [GUID]::NewGuid().ToString()
$CoverletOutput = [IO.Path]::Combine($SolutionDir, $CoverageCoverletDir, $CoverageRunIdentifier)

# Build and Test
dotnet.exe test $Solution --collect:"$Collect" --results-directory:"$CoverletOutput" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format="$DataCollectorFormat"

# Calculated Parameters - Report Generator - CHANGE WITH EXTREME CAUTION
$TargetDir = [IO.Path]::Combine($CoverageReportDir, $CoverageRunIdentifier)
$ReportHtmlFile = [IO.Path]::Combine($SolutionDir, $CoverageReportDir, $CoverageRunIdentifier, $HtmlReportIndexFileName)
$TestResultsDirs = Join-Path $CoverletOutput -ChildPath **\*
$CoverageFiles = (Split-Path $TestResultsDirs -Resolve | ForEach-Object -Process {[IO.Path]::Combine($_, $CoverageFileName)}) -join ";"

# Generate Report
reportgenerator.exe "-reports:$CoverageFiles" "-targetdir:$TargetDir" "-reporttypes:$ReportTypes"

# Open Report
Invoke-Item $ReportHtmlFile
</code></pre>
<p>If you create the script by copy pasting, you might need to change the execution policy to be able to run it (or sign the certificate yourself). If you change the execution policy, I would recommend to use RemoteSigned, so you can run your own scripts locally. To do that, open Powershell as administrator and run:</p>
<pre><code>Set-ExecutionPolicy RemoteSigned
</code></pre>
<p>The scripts are kind of self explanatory at this point, feel free to change them and do any modifications. They are thought to be run from inside a scripts directory in the solution directory:</p>
<pre><code>UnitTestCoverageDemo
|
|_ scripts
| |
| |_ run_tests.sh
| |
| |_ run_tests.ps1
|
|_ UnitTestCoverageDemo.sln
|
*
*
</code></pre>
<p>If you want to use a different directory structure, you might need to do some modifications to them. Executing this scripts will run the tests, create the coverage files, create the report and open the report.</p>
<h2>Thanks!</h2>
<p>Thanks for reading this article! I hope this was helpful and as fun to read as it was to write! I'll leave the link to my GitHub repository with the code I've done here!</p>
<p><a href="https://github.com/fedeantuna/UnitTestCoverageDemo">GitHub link</a></p>
</div></article></main><div class="mb-5"><a href="/">← Back to home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"id":"net-core-open-source-unit-test-coverage-and-reports","contentHtml":"\u003cp\u003eWhen I work on my personal projects I normally use Visual Studio Community or Visual Studio Code. Lately I decided to pay more attention to the coverage on those projects, and being used to having the Visual Studio Enterprise subscription on my job, I tried to run the \"Analyze Code Coverage for All Tests\" from Visual Studio. It turns out that that options is only available for the Enterprise edition. After a second of frustration it came to my mind the question \"if I depend on Visual Studio to analyze the code coverage, what am I going to do when working on my Fedora laptop?\", so I did some investigation and found a way (there a lot of ways actually) to run the analysis on both, my Windows and Linux machines.\u003c/p\u003e\n\u003ch2\u003eCode on GitHub\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/fedeantuna/UnitTestCoverageDemo\"\u003eGitHub link\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eSetting up the demo projects\u003c/h2\u003e\n\u003cp\u003eIn order to provide a more \"realistic\" scenario, I will be creating multiple projects. I will also use mostly the console so it doesn't matter what OS or editor you are using, you should be able to follow along. Keep in mind that in some cases you'll to change the forward slashes to backslashes on Windows.\u003c/p\u003e\n\u003cp\u003eOpen the console and navigate to any directory where you want to set up the solution and run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emkdir UnitTestCoverageDemo\ncd UnitTestCoverageDemo\ndotnet new sln\nmkdir src\nmkdir tests\ncd src\ndotnet new classlib -n UnitTestCoverageDemo.Calculations\ndotnet new classlib -n UnitTestCoverageDemo.Services\ndotnet add UnitTestCoverageDemo.Services/UnitTestCoverageDemo.Services.csproj reference UnitTestCoverageDemo.Calculations/UnitTestCoverageDemo.Calculations.csproj\ncd ../tests\ndotnet new xunit -n UnitTestCoverageDemo.Calculations.Tests\ndotnet new xunit -n UnitTestCoverageDemo.Services.Tests\ndotnet add UnitTestCoverageDemo.Calculations.Tests/UnitTestCoverageDemo.Calculations.Tests.csproj reference ../src/UnitTestCoverageDemo.Calculations/UnitTestCoverageDemo.Calculations.csproj\ndotnet add UnitTestCoverageDemo.Services.Tests/UnitTestCoverageDemo.Services.Tests.csproj reference ../src/UnitTestCoverageDemo.Services/UnitTestCoverageDemo.Services.csproj\ncd ..\ndotnet sln UnitTestCoverageDemo.sln add ./**/**/**.csproj\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow lets open the solution using some editor. First, delete every auto-generated class and then create a couple of classes for each non-test project.\u003c/p\u003e\n\u003cp\u003eOn UnitTestCoverageDemo.Calculations, create SimpleCalculation.cs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eusing System;\n\nnamespace UnitTestCoverageDemo.Calculations\n{\n    public class SimpleCalculation\n    {\n        public Int32 Add(Int32 n, Int32 m)\n        {\n            return n + m;\n        }\n\n        public Int32 Substract(Int32 n, Int32 m)\n        {\n            return n - m;\n        }\n\n        public Int32 Multiply(Int32 n, Int32 m)\n        {\n            return n * m;\n        }\n\n        public Int32 Divide(Int32 n, Int32 m)\n        {\n            if (m == 0)\n            {\n                throw new ArgumentOutOfRangeException(nameof(m));\n            }\n\n            return n / m;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn UnitTestCoverageDemo.Calculations, create ComplexCalculation.cs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eusing System;\n\nnamespace UnitTestCoverageDemo.Calculations\n{\n    public class ComplexCalculation\n    {\n        public Int32 Power(Int32 n, Int32 m)\n        {\n            if (m == 0)\n            {\n                return 1;\n            }\n\n            var result = n;\n            for (int i = 1; i \u0026#x3C; m; i++)\n            {\n                result *= n;\n            }\n\n            return result;\n        }\n\n        public Int32 Round(Decimal n)\n        {\n            var intPart = (Int32)n;\n            var difference = n - intPart;\n\n            if (difference \u003e= 0.5M)\n            {\n                return intPart + 1;\n            }\n\n            return intPart;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn UnitTestCoverageDemo.Services, create FigureService.cs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eusing System;\nusing UnitTestCoverageDemo.Calculations;\n\nnamespace UnitTestCoverageDemo.Services\n{\n    public class FigureService\n    {\n        private readonly SimpleCalculation _simpleCalculation;\n        private readonly ComplexCalculation _complexCalculation;\n\n        public FigureService()\n        {\n            // Who's got time for DI anyways?\n            this._simpleCalculation = new SimpleCalculation();\n            this._complexCalculation = new ComplexCalculation();\n        }\n\n        public Int32 SquareArea(Int32 s)\n        {\n            var area = this._complexCalculation.Power(s, 2);\n\n            return area;\n        }\n\n        public Int32 RectangleArea(Int32 b, Int32 h)\n        {\n            var area = this._simpleCalculation.Multiply(b, h);\n\n            return area;\n        }\n\n        public Int32 TriangleArea(Int32 b, Int32 h)\n        {\n            var doubleArea = this._simpleCalculation.Multiply(b, h);\n            var area = this._simpleCalculation.Divide(doubleArea, 2);\n\n            return area;\n        }\n\n        public Int32 RectanglePerimeter(Int32 b, Int32 h)\n        {\n            var halfPerimeter = this._simpleCalculation.Add(b, h);\n            var perimeter = this._simpleCalculation.Multiply(halfPerimeter, 2);\n\n            return perimeter;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn UnitTestCoverageDemo.Services, create MoneyService.cs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eusing System;\nusing UnitTestCoverageDemo.Calculations;\n\nnamespace UnitTestCoverageDemo.Services\n{\n    public class MoneyService\n    {\n        private readonly SimpleCalculation _simpleCalculation;\n        private readonly ComplexCalculation _complexCalculation;\n\n        public MoneyService()\n        {\n            // Who's got time for DI anyways?\n            this._simpleCalculation = new SimpleCalculation();\n            this._complexCalculation = new ComplexCalculation();\n        }\n\n        public Int32 Spend(Int32 money, Int32 price)\n        {\n            if (money \u0026#x3C; price)\n            {\n                throw new ArgumentOutOfRangeException(nameof(price));\n            }\n\n            var left = this._simpleCalculation.Substract(money, price);\n\n            return left;\n        }\n\n        public Int32 ForgetTheChange(Decimal money)\n        {\n            var withoutTheChange = this._complexCalculation.Round(money);\n\n            return withoutTheChange;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn UnitTestCoverageDemo.Calculations.Tests, create ComplexCalculationTests.cs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eusing System;\nusing Xunit;\n\nnamespace UnitTestCoverageDemo.Calculations.Tests\n{\n    public class ComplexCalculationTests\n    {\n        private readonly ComplexCalculation _sut;\n\n        public ComplexCalculationTests()\n        {\n            this._sut = new ComplexCalculation();\n        }\n\n        [Theory]\n        [InlineData(5, 2, 25)]\n        [InlineData(2, 3, 8)]\n        [InlineData(5, 0, 1)]\n        public void Power_Returns_FirstParameterElevatedToTheSecondParameter(Int32 firstParameter, Int32 secondParameter, Int32 expectedResult)\n        {\n            // Arrange\n\n            // Act\n            var result = this._sut.Power(firstParameter, secondParameter);\n\n            // Assert\n            Assert.Equal(expectedResult, result);\n        }\n\n        [Theory]\n        [InlineData(5.25, 5)]\n        [InlineData(7.5, 8)]\n        [InlineData(6.75, 7)]\n        public void Round_Returns_RoundedNumber(Decimal number, Int32 expectedResult)\n        {\n            // Arrange\n\n            // Act\n            var result = this._sut.Round(number);\n\n            // Assert\n            Assert.Equal(expectedResult, result);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn UnitTestCoverageDemo.Services.Tests, create MoneyServiceTests.cs.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eusing System;\nusing Xunit;\n\nnamespace UnitTestCoverageDemo.Services.Tests\n{\n    public class MoneyServiceTests\n    {\n        private readonly MoneyService _sut;\n\n        public MoneyServiceTests()\n        {\n            this._sut = new MoneyService();\n        }\n\n        [Theory]\n        [InlineData(200, 50, 150)]\n        [InlineData(300, 300, 0)]\n        public void Spend_Returns_RemainingMoney(Int32 money, Int32 price, Int32 remaining)\n        {\n            // Arrange\n\n            // Act\n            var result = this._sut.Spend(money, price);\n\n            // Assert\n            Assert.Equal(remaining, result);\n        }\n\n        [Theory]\n        [InlineData(10.89, 11)]\n        [InlineData(250.35, 250)]\n        public void ForgetTheChange_Returns_RoundedMoney(Decimal money, Int32 rounded)\n        {\n            // Arrange\n\n            // Act\n            var result = this._sut.ForgetTheChange(money);\n\n            // Assert\n            Assert.Equal(rounded, result);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eInstalling required packages and tools\u003c/h2\u003e\n\u003cp\u003eNow that we have our project set, we can run our tests. Open a console on the solution directory and run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edotnet test\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou'll see that they run successfully but no information about our current coverage, which of course is extremely poor. So, let's install what we need.\u003c/p\u003e\n\u003cp\u003eWe need coverlet.collector NuGet package on each Unit Test project, we can check that they are installed running from the solution directory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edotnet list package\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the package appears on the list then we are ready to go, if not (or if you want to update it) run from each project directory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edotnet add package coverlet.collector\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow lets install the Report Generator as a global tool.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edotnet tool install --global dotnet-reportgenerator-globaltool\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf already installed, run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edotnet tool update --global dotnet-reportgenerator-globaltool\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eGenerating the report\u003c/h2\u003e\n\u003cp\u003eTo generate the reports, we need to run the test command with some additional parameters that will generate files containing information about our coverage. We will use the cobertura format here but you can read about other formats \u003ca href=\"https://github.com/coverlet-coverage/coverlet\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eRun the following command from the solution directory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edotnet test --collect:\"XPlat Code Coverage\" --results-directory:\"./.coverage\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \"XPlat Code Coverage\" argument is a friendly name that corresponds to the data collectors from Coverlet. You can read more about it \u003ca href=\"https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-code-coverage\"\u003ehere\u003c/a\u003e. The \"./.coverage\" is to specify the directory where the results will be stored. If none is specified, it will default to a TestResults directory inside each project.\u003c/p\u003e\n\u003cp\u003eInside the \".coverage\" directory we have now two directories with GUID as names and inside those directories we have two files named \"coverage.cobertura.xml\". Those files contain the result for our code coverage analysis, but unless you're fluent in XML (I'm not), then there is not much use for us as humans. So let's create a readable report that is friendlier to our eyes.\u003c/p\u003e\n\u003cp\u003eRun the following on the terminal from the solution directory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ereportgenerator \"-reports:.coverage/**/*.cobertura.xml\" \"-targetdir:.coverage-report/\" \"-reporttypes:HTML;\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we now open the index.html file inside the .coverage-report directory, we will see a much nicer report that tells us that we suck at covering because we didn't even cover half of our code, but at least we now have all the details to easily correct this.\u003c/p\u003e\n\u003cp\u003eBefore continuing let's analyze the command. Our first parameter \"-reports:.coverage/*\u003cem\u003e/\u003c/em\u003e.cobertura.xml\" is going to find all the \"coverage.cobertura.xml\" files regardless of the GUID naming the directories. The second parameter \"-targetdir:.coverage-report/\" will just tell the Report Generator where to store the final report, and the last parameter \"-reporttypes:HTML;\" will generate an HTML report for us to view on the browser. If you want to know more in detail about all the possible options, you can read more here.\u003c/p\u003e\n\u003ch2\u003eAutomating the process\u003c/h2\u003e\n\u003cp\u003eAll of this is great, but it is really painful to run this manually every time, and besides that if you think of the directory structure that is going to be created for a second, you'll see a bigger problem... yeah, that's right, unless we delete everything before the next run we will have no way to identify which files are the ones for that run, because the GUIDs are randomly generated. Let's make everything better then with some scripts. I made a couple, one for Linux and one for Windows. If you are on a MAC I assume that the Linux one will work just fine, but it might need a few modifications.\u003c/p\u003e\n\u003cp\u003eLinux Script (BASH):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#!/usr/bin/bash\n# Parameters - Solution\nSOLUTION_FILE_NAME=\"\"\nCOVERAGE_COVERLET_DIR=\".coverage\"\nCOVERAGE_REPORT_DIR=\".coverage-report\"\n\n# Parameters - Coverlet\nDATA_COLLECTOR_FORMAT=\"cobertura\"\nCOVERLET_OUTPUT_FORMAT=\"cobertura\"\nCOVERLET_OUTPUT_EXTENSION=\".xml\"\nCOLLECT=\"XPlat Code Coverage\"\nCOVERAGE_FILE_NAME=\"coverage.$COVERLET_OUTPUT_FORMAT$COVERLET_OUTPUT_EXTENSION\"\n\n# Parameters - Report Generator\nREPORT_TYPES=\"HTML;cobertura;\"\nHTML_REPORT_INDEX_FILE_NAME=\"index.html\"\n\n# Calculated Parameters - Solution - CHANGE WITH EXTREME CAUTION\nSOLUTION_DIR=\"$(dirname $(cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" \u0026#x26;\u0026#x26; pwd))\"\nSOLUTION=\"$SOLUTION_DIR/$SOLUTION_FILE_NAME\"\n\n# Calculated Parameters - Coverlet - CHANGE WITH EXTREME CAUTION\nCOVERAGE_RUN_IDENTIFIER=$(uuidgen)\nCOVERLET_OUTPUT=\"$SOLUTION_DIR/$COVERAGE_COVERLET_DIR/$COVERAGE_RUN_IDENTIFIER\"\n\n# Build and Test\ndotnet test $SOLUTION --collect:\"$COLLECT\" --results-directory:\"$COVERLET_OUTPUT\" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=\"$DATA_COLLECTOR_FORMAT\"\n\n# Calculated Parameters - Report Generator - CHANGE WITH EXTREME CAUTION\nTARGET_DIR=\"$COVERAGE_REPORT_DIR/$COVERAGE_RUN_IDENTIFIER\"\nREPORT_HTML_FILE=\"$SOLUTION_DIR/$COVERAGE_REPORT_DIR/$COVERAGE_RUN_IDENTIFIER/$HTML_REPORT_INDEX_FILE_NAME\"\nCOVERAGE_FILES=$(find $COVERLET_OUTPUT/**/* -maxdepth 1 | awk -vORS=\";\" '{ print $1 }' | sed \"s/\\;$/\\n/\")\n\n# Generate Report\nreportgenerator \"-reports:$COVERAGE_FILES\" \"-targetdir:$TARGET_DIR\" \"-reporttypes:$REPORT_TYPES\"\n\n# Open Report\nxdg-open $REPORT_HTML_FILE \u003e /dev/null 2\u003e\u0026#x26;1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor this script to run properly you will also need to install uuidgen tool. On Fedora, CentOS and RHEL (if not already installed) it is on the util-linux package, util-linux-ng for CentOS 6. On Debian the package is called uuid-runtime. On other distributions it might be better for you to search for it online or try running the uuidgen command to see if you already have it. Remember to also grant execution permissions to the script.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003echmod u+x run_tests.sh #or whatever name you used\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWindows Script (Powershell):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Parameters - Solution\n$SolutionFileName = \"WAM.sln\"\n$CoverageCoverletDir = \".coverage\"\n$CoverageReportDir = \".coverage-report\"\n\n# Parameters - Coverlet\n$DataCollectorFormat = \"cobertura\"\n$CoverletOutputFormat = \"cobertura\"\n$CoverletOutputExtension = \".xml\"\n$Collect = \"XPlat Code Coverage\"\n$CoverageFileName = \"coverage.$CoverletOutputFormat$CoverletOutputExtension\"\n\n# Parameters - Report Generator\n$ReportTypes = \"HTML;cobertura;\"\n$HtmlReportIndexFileName = \"index.html\"\n\n# Calculated Parameters - Solution - CHANGE WITH EXTREME CAUTION\n$SolutionDir = (Get-Item $PSScriptRoot).Parent.FullName\n$Solution = [IO.Path]::Combine($SolutionDir, $SolutionFileName)\n\n# Calculated Parameters - Coverlet - CHANGE WITH EXTREME CAUTION\n$CoverageRunIdentifier = [GUID]::NewGuid().ToString()\n$CoverletOutput = [IO.Path]::Combine($SolutionDir, $CoverageCoverletDir, $CoverageRunIdentifier)\n\n# Build and Test\ndotnet.exe test $Solution --collect:\"$Collect\" --results-directory:\"$CoverletOutput\" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=\"$DataCollectorFormat\"\n\n# Calculated Parameters - Report Generator - CHANGE WITH EXTREME CAUTION\n$TargetDir = [IO.Path]::Combine($CoverageReportDir, $CoverageRunIdentifier)\n$ReportHtmlFile = [IO.Path]::Combine($SolutionDir, $CoverageReportDir, $CoverageRunIdentifier, $HtmlReportIndexFileName)\n$TestResultsDirs = Join-Path $CoverletOutput -ChildPath **\\*\n$CoverageFiles = (Split-Path $TestResultsDirs -Resolve | ForEach-Object -Process {[IO.Path]::Combine($_, $CoverageFileName)}) -join \";\"\n\n# Generate Report\nreportgenerator.exe \"-reports:$CoverageFiles\" \"-targetdir:$TargetDir\" \"-reporttypes:$ReportTypes\"\n\n# Open Report\nInvoke-Item $ReportHtmlFile\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you create the script by copy pasting, you might need to change the execution policy to be able to run it (or sign the certificate yourself). If you change the execution policy, I would recommend to use RemoteSigned, so you can run your own scripts locally. To do that, open Powershell as administrator and run:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSet-ExecutionPolicy RemoteSigned\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe scripts are kind of self explanatory at this point, feel free to change them and do any modifications. They are thought to be run from inside a scripts directory in the solution directory:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eUnitTestCoverageDemo\n|\n|_ scripts\n| |\n| |_ run_tests.sh\n| |\n| |_ run_tests.ps1\n|\n|_ UnitTestCoverageDemo.sln\n|\n*\n*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you want to use a different directory structure, you might need to do some modifications to them. Executing this scripts will run the tests, create the coverage files, create the report and open the report.\u003c/p\u003e\n\u003ch2\u003eThanks!\u003c/h2\u003e\n\u003cp\u003eThanks for reading this article! I hope this was helpful and as fun to read as it was to write! I'll leave the link to my GitHub repository with the code I've done here!\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/fedeantuna/UnitTestCoverageDemo\"\u003eGitHub link\u003c/a\u003e\u003c/p\u003e\n","title":".NET Core - Open Source Unit Test Coverage and Reports","date":"2020-10-11"}},"__N_SSG":true},"page":"/article/[id]","query":{"id":"net-core-open-source-unit-test-coverage-and-reports"},"buildId":"goSFXIkQb1bxfyAA507mj","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8f31809deb7932dd0187.js"></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.4b81eedf2fcdb09bf521.js" async=""></script><script src="/_next/static/chunks/commons.4825e5e9d187cd4ab7dd.js" async=""></script><script src="/_next/static/chunks/main-86c34d104cdfe5877fdd.js" async=""></script><script src="/_next/static/chunks/pages/_app-3972a0229e6401e497b7.js" async=""></script><script src="/_next/static/chunks/63c1bd8fe8e29f7d1674476eb835b66f2691ac72.43955d3384b90be5bcd0.js" async=""></script><script src="/_next/static/chunks/pages/article/%5Bid%5D-898c033ca875c80508bb.js" async=""></script><script src="/_next/static/goSFXIkQb1bxfyAA507mj/_buildManifest.js" async=""></script><script src="/_next/static/goSFXIkQb1bxfyAA507mj/_ssgManifest.js" async=""></script></body></html>