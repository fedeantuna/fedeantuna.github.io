{"pageProps":{"article":{"id":"console-app-with-di-configuration-and-logging","contentHtml":"<p>If you ever wrote an ASP.NET Core Web Application or API, you surely know that the framework itself leans you into using its own Container for Dependency Injection. The same thing happens with the Configuration and Logging features. They are great, light weight and easy to use out of the box solutions for ASP.NET Core, but not as out of the box for a simple Console Application.</p>\n<p>I'm assuming you already have everything installed and know enough to use NuGet Packages, the basics of Dependency Injection, Configuration and Logging since we will not be diving into that here. This article is about how to set up a Console Application to take advantage of those features.</p>\n<h2>Lets Code!</h2>\n<p><em>If you just want to follow the guide without writing the code yourself, you can follow the link to my GitHub repository that has the code we are going to follow.</em></p>\n<p><a href=\"https://github.com/fedeantuna/ConsoleAppWithDI\">GitHub Repository</a></p>\n<h2>Adding Dependency Injection to Console App</h2>\n<p>I'll be using the Command Line Interface and Visual Studio Code on a Fedora 31 machine, but you should be able to follow this from any environment you want.</p>\n<p>Open your terminal, create a directory and inside, a Console App project.</p>\n<pre><code>mkdir ConsoleAppWithDI\ncd ConsoleAppWithDI\ndotnet new sln\ndotnet new console -n ConsoleAppWithDI.UI\ndotnet sln add ConsoleAppWithDI.UI/ConsoleAppWithDI.UI.csproj\n</code></pre>\n<p>These commands will set up the typical Solution with the Console App project. Now lets add the required NuGet package for DI: Microsoft.Extensions.DependencyInjection</p>\n<pre><code>cd ConsoleAppWithDI.UI\ndotnet add package Microsoft.Extensions.DependencyInjection\n</code></pre>\n<p>Open the solution in your favorite IDE, if you are on Windows with Visual Studio installed, you can just double click the created Solution. I'm going to open this on Visual Studio Code.</p>\n<pre><code>cd ..\ncode .\n</code></pre>\n<p>As in an ASP.NET Core Application, we will configure multiple services and instantiate a provider. So lets start by creating the Startup class in a Startup.cs file in the same directory that is our Program.cs.</p>\n<pre><code>using Microsoft.Extensions.DependencyInjection;\n\nnamespace ConsoleAppWithDI.UI\n{\n    public static class Startup\n    {\n        public static IServiceCollection ConfigureServices()\n        {\n            var serviceCollection = new ServiceCollection();\n\n            // We'll come back here later to set up an entry point and\n            // our services\n\n            return serviceCollection;\n        }\n    }\n}\n</code></pre>\n<p>Now lets add the class for the Entry Point of our Application. I usually name this class as EntryPoint but you can name it whatever you want!</p>\n<pre><code>using System;\n\nnamespace ConsoleAppWithDI.UI\n{\n    public class EntryPoint\n    {\n        public void Run(String[] args)\n        {\n            // Our logic\n        }\n    }\n}\n</code></pre>\n<p>We already have the Entry Point and the Container ready to set up services, but we need to put all of this together. If we run the application like it is, it will just output \"Hello world!\" and ignore everything else we did. We have to replace the code on our Main method, inside our Program class, to call the DI Container and our new Entry Point.</p>\n<pre><code>using System;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace ConsoleAppWithDI.UI\n{\n    public class Program\n    {\n        public static void Main(String[] args)\n        {\n            var services = Startup.ConfigureServices();\n            var serviceProvider = services.BuildServiceProvider();\n\n            serviceProvider.GetService&#x3C;EntryPoint>().Run(args);\n        }\n    }\n}\n</code></pre>\n<p>And now we register the EntryPoint class as a transient in the Startup class</p>\n<pre><code>...\n\npublic static IServiceCollection ConfigureServices()\n{\n    var services = new ServiceCollection();\n\n    services.AddTransient&#x3C;EntryPoint>();\n\n    return services;\n}\n\n...\n</code></pre>\n<p>Alright! We have everything set up for DI! Now we are able to use our Startup class to configure the container as we would on a ASP.NET Core Application. Lets add a small service that we can inject to see if everything works as expected! Lets try to calculate the roots of a second degree polynomial, ignoring complex roots. If you don't know or don't remember, here is the formula we have to use</p>\n<p><img src=\"/images/console-app-with-di-configuration-and-logging-01.png\" alt=\"quadratic formula\"></p>\n<p>Lets start by adding a QuadraticRoots entity. I won't be following any pattern here, so please don't take this as a DDD guide, it's just a simple example to test out our Dependency Injection.</p>\n<pre><code>using System;\n\nnamespace ConsoleAppWithDI.UI.Entities\n{\n    public class QuadraticRoots\n    {\n        public Double FirstRoot { get; set; }\n        public Double SecondRoot { get; set; }\n    }\n}\n</code></pre>\n<p>Now we will add the Interface for our service.</p>\n<pre><code>using System;\nusing ConsoleAppWithDI.UI.Entities;\n\nnamespace ConsoleAppWithDI.UI.Services\n{\n    public interface IQuadraticService\n    {\n        QuadraticRoots CalculateRoots(Double a, Double b, Double c);\n    }\n}\n</code></pre>\n<p>And the actual service.</p>\n<pre><code>using System;\nusing ConsoleAppWithDI.UI.Entities;\n\nnamespace ConsoleAppWithDI.UI.Services\n{\n    public class QuadraticService : IQuadraticService\n    {\n        public QuadraticRoots CalculateRoots(Double a, Double b, Double c)\n        {\n            var discriminant = Math.Pow(b, 2) - (4 * a * c);\n\n            if (discriminant &#x3C; 0)\n            {\n                return null;\n            }\n\n            var quadraticRoots = new QuadraticRoots();\n\n            if (discriminant ==  0)\n            {\n                quadraticRoots.FirstRoot = quadraticRoots.SecondRoot = ((- b) + (Math.Sqrt(discriminant))) / (2 * a);\n            }\n            else\n            {\n                quadraticRoots.FirstRoot = ((- b) + (Math.Sqrt(discriminant))) / (2 * a);\n                quadraticRoots.SecondRoot = ((- b) - (Math.Sqrt(discriminant))) / (2 * a);\n            }\n\n            return quadraticRoots;\n        }\n    }\n}\n</code></pre>\n<p>Lets go back to our Startup class so we can register our new service there.</p>\n<pre><code>using ConsoleAppWithDI.UI.Services;\nusing Microsoft.Extensions.DependencyInjection;\n\n...\n\npublic static IServiceCollection ConfigureServices()\n{\n    var services = new ServiceCollection();\n\n    services.AddSingleton&#x3C;IQuadraticService, QuadraticService>();\n\n    services.AddTransient&#x3C;EntryPoint>();\n\n    return services;\n}\n\n...\n</code></pre>\n<p>That's it! Now we can inject our service through a constructor into our EntryPoint class, lets try that.</p>\n<pre><code>using System;\nusing ConsoleAppWithDI.UI.Services;\n\n...\n\npublic class EntryPoint\n{\n    private readonly IQuadraticService _quadraticService;\n\n    public EntryPoint(IQuadraticService quadraticService)\n    {\n        this._quadraticService = quadraticService;\n    }\n\n...\n</code></pre>\n<p>Great! Lets take the arguments from the command line to set the polynomial coefficients in order (a, b, c). We need to modify the Run method in the EntryPoint class.</p>\n<pre><code>...\n\npublic void Run(String[] args)\n{\n    var a = Double.Parse(args[0]);\n    var b = Double.Parse(args[1]);\n    var c = Double.Parse(args[2]);\n\n    var quadraticRoots = this._quadraticService.CalculateRoots(a, b, c);\n\n    Console.WriteLine($\"Polynomial: {a}x^2 + {b}x + {c}\");\n    if (quadraticRoots == null)\n    {\n        Console.WriteLine(\"The roots are not reals\");\n    }\n    else if (quadraticRoots.FirstRoot == quadraticRoots.SecondRoot)\n    {\n        Console.WriteLine($\"The double root is {quadraticRoots.FirstRoot}\");\n    }\n    else\n    {\n        Console.WriteLine($\"The roots are: {quadraticRoots.FirstRoot} and {quadraticRoots.SecondRoot}\");\n    }\n}\n</code></pre>\n<p>It is not perfect but it works! We could have made use of some design pattern to avoid checking for nulls or doing so many checks for one simple output, but that's not the point here.</p>\n<p>This is not hard to implement and we can have a much more sophisticated Console Application using the built-in Dependency Injection from ASP.NET Core.</p>\n<p>We can run it from the command line, inside the project directory just execute the run command with the parameters you want for the coefficients. Since we haven't done any validation for the user inputs nor prepare for weird scenarios, it will fail if you miss a coefficient or pass text instead of numbers. You know it will... go easy on our app!</p>\n<pre><code>dotnet run 1 2 1\n</code></pre>\n<h2>Adding Configuration to our Console App</h2>\n<p>Go back to the terminal and navigate to the project directory. If you are using Visual Studio you can go to the NuGet Package Manager. We will install the Microsoft.Extensions.Configuration.Json package.</p>\n<pre><code>cd ConsoleAppWithDI.UI\ndotnet add package Microsoft.Extensions.Configuration.Json\n</code></pre>\n<p>With the package in place we can go back to our IDE and add the following to the Startup class.</p>\n<pre><code>using System.IO;\nusing ConsoleAppWithDI.UI.Services;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\n\n...\n\npublic static IServiceCollection ConfigureServices()\n{\n    var services = new ServiceCollection();\n\n    var builder = new ConfigurationBuilder()\n        .SetBasePath(Directory.GetCurrentDirectory())\n        .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: false);\n    IConfiguration configuration = builder.Build();\n    services.AddSingleton(configuration);\n\n    services.AddSingleton&#x3C;IQuadraticService, QuadraticService>();\n\n    services.AddTransient&#x3C;EntryPoint>();\n\n    return services;\n}\n</code></pre>\n<p>Here I'm using optional: true, reloadOnChange: false and my current directory as the BasePath, but you can change those values to whatever suits you better.</p>\n<p>That's all! We are ready to inject the Configuration as well. Lets try to read the values for our roots calculator from our settings! First we need to create our appsettings.json file with the following content.</p>\n<pre><code>{\n    \"PolynomialCoefficients\": {\n        \"A\": 1,\n        \"B\": 2,\n        \"C\": 1\n    }\n}\n</code></pre>\n<p>If you are doing this from Visual Studio, you can just right click your new appsettings.json file, go to Properties and set the \"Copy to Output Directory\" to \"Preserve newest\". In case you are using Visual Studio Code or other Text Editor, you can do it by editing the csproj file.</p>\n<pre><code>...\n\n&#x3C;ItemGroup>\n  &#x3C;None Update=\"appsettings.json\">\n    &#x3C;CopyToOutputDirectory>PreserveNewest&#x3C;/CopyToOutputDirectory>\n  &#x3C;/None>\n&#x3C;/ItemGroup>\n\n...\n</code></pre>\n<p>Now lets inject the Configuration into the EntryPoint class. We will use the values for the polynomial coefficients from the appsettings.json file. I know, we are actually making the application worse, but it's just to demo the Configuration. We are going to get rid of this later, I promise!</p>\n<pre><code>using System;\nusing ConsoleAppWithDI.UI.Services;\nusing Microsoft.Extensions.Configuration;\n\n...\n\nprivate readonly IQuadraticService _quadraticService;\nprivate readonly IConfiguration _configuration;\n\n\npublic EntryPoint(IQuadraticService quadraticService, IConfiguration configuration)\n{\n    this._quadraticService = quadraticService;\n    this._configuration = configuration;\n}\n\n...\n\npublic void Run(String[] args)\n{\n    var a = Double.Parse(this._configuration[\"PolynomialCoefficients:A\"]);\n    var b = Double.Parse(this._configuration[\"PolynomialCoefficients:B\"]);\n    var c = Double.Parse(this._configuration[\"PolynomialCoefficients:C\"]);\n\n...\n</code></pre>\n<p>If we run the application now, we can do it without any arguments. It will take the values from the appsettings file.</p>\n<pre><code>dotnet run\n</code></pre>\n<h2>Adding Logging to our Console App</h2>\n<p>The .NET Core Logging is not really hard to implement, but it won't write log to files or databases out of the box. I'm going to first show you how to implement it so it can write its output to the console and then to files using Serilog, an open source third party logger.</p>\n<p>First we need to install the Microsoft.Extensions.Logging.Console package. You can do it from the NuGet Package Manager or the terminal.</p>\n<pre><code>dotnet add package Microsoft.Extensions.Logging.Console\n</code></pre>\n<p>Once you've done that, the only thing we need to set up the Logging is to add a small block into the Startup class</p>\n<pre><code>using System.IO;\nusing ConsoleAppWithDI.UI.Services;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\n\n...\n\npublic static IServiceCollection ConfigureServices()\n{\n    var services = new ServiceCollection();\n\n    var builder = new ConfigurationBuilder()\n        .SetBasePath(Directory.GetCurrentDirectory())\n        .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: false);\n    IConfiguration configuration = builder.Build();\n    services.AddSingleton(configuration);\n\n    services.AddLogging(builder =>\n    {\n        builder.AddConfiguration(configuration.GetSection(\"Logging\"));\n        builder.AddConsole();\n    });\n\n...\n</code></pre>\n<p>In order for this to work, we have to add the Logging section to our configuration. So lets delete the previous content from the appsettings.json file and place instead the Logging settings.</p>\n<pre><code>{\n    \"Logging\": {\n        \"LogLevel\": {\n            \"Default\": \"Debug\"\n        }\n    }\n}\n</code></pre>\n<p>Now we need to inject the logger in the EntryPoint class and, as I promised, change the way we tell our app the polynomial coefficients to be again by arguments.</p>\n<pre><code>using System;\nusing ConsoleAppWithDI.UI.Services;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.Logging;\n\n...\n\nprivate readonly IQuadraticService _quadraticService;\nprivate readonly IConfiguration _configuration;\nprivate readonly ILogger&#x3C;EntryPoint> _logger;\n\npublic EntryPoint(IQuadraticService quadraticService, IConfiguration configuration, ILogger&#x3C;EntryPoint> logger)\n{\n    this._quadraticService = quadraticService;\n    this._configuration = configuration;\n    this._logger = logger;\n}\n\n...\n\npublic void Run(String[] args)\n{\n    var a = Double.Parse(args[0]);\n    var b = Double.Parse(args[1]);\n    var c = Double.Parse(args[2]);\n\n    this._logger.LogDebug(\"The coefficients have been set!\");\n\n...\n</code></pre>\n<p>If you now run the application you'll see the logging message in the console.</p>\n<pre><code>dotnet run 1 2 1\n</code></pre>\n<h2>Adding Serilog to our Console App</h2>\n<p>Lets add the Serilog packages so we can add to the Console output a text file output.</p>\n<p>First we install the following packages:</p>\n<ul>\n<li>Serilog.Sinks.File</li>\n<li>Serilog.Extensions.Logging</li>\n<li>Serilog.Settings.Configuration</li>\n</ul>\n<pre><code>dotnet add package Serilog.Sinks.File\ndotnet add package Serilog.Extensions.Logging\ndotnet add package Serilog.Settings.Configuration\n</code></pre>\n<p>Once those packages are added, we have to make a small change into the Startup class.</p>\n<pre><code>using System.IO;\nusing ConsoleAppWithDI.UI.Services;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing Serilog;\n\n...\n\npublic static IServiceCollection ConfigureServices()\n{\n    var services = new ServiceCollection();\n    var builder = new ConfigurationBuilder()\n        .SetBasePath(Directory.GetCurrentDirectory())\n        .AddJsonFile(\"appsettings.json\", optional: false, reloadOnChange: false);\n    IConfiguration configuration = builder.Build();\n\n    Log.Logger = new LoggerConfiguration()\n        .ReadFrom.Configuration(configuration)\n        .CreateLogger();\n\n    services.AddLogging(builder =>\n    {\n        builder.AddConfiguration(configuration.GetSection(\"Logging\"));\n        builder.AddConsole();\n        builder.AddSerilog();\n    });\n\n...\n</code></pre>\n<p>Now for the Serilog configuration we need to add another section inside the appsettings.json file.</p>\n<pre><code>{\n    \"Logging\": {\n        \"LogLevel\": {\n            \"Default\": \"Debug\"\n        }\n    },\n    \"Serilog\": {\n        \"MinimumLevel\": \"Debug\",\n        \"WriteTo\": [\n            {\n                \"Name\": \"File\",\n                \"Args\": {\n                    \"Path\": \"LOG_PATH\"\n                }\n            }\n        ]\n    }\n}\n</code></pre>\n<p>Replace the LOG_PATH value with an actual path to a file, like \"/home/myuser/console.log\" if you are on a Linux OS or \"C:\\Users\\MyUser\\Console.log\". If you run the application now you can see that the file is created and the log that you can see in the console is also stored there.</p>\n<pre><code>dotnet run 1 2 1\n</code></pre>\n<p>I recommend you that, if you don't know already, check out more about Serilog! This example was extremely superficial compared to what it can do. It's a really powerful tool!</p>\n<p><a href=\"https://serilog.net/\">Serilog</a></p>\n<h2>Thanks!</h2>\n<p>Thanks for reading this article! I hope this was helpful and as fun to read as it was to write! I'll leave the link to my GitHub repository with the code I've done here!</p>\n","title":"How to build a .NET Core 3.1 Console Application with built-in Dependency Injection, Configuration and Logging","date":"2020-02-08"}},"__N_SSG":true}